% !TEX root = ../thesis.tex


\chapter{Appendix}
\section{DMD}
\subsection{Theory -- Floyd-Steinberg Dithering}
\begin{algorithm}
    \caption{The Floyd-Steinberg Dithering Algorithm}
    \label{alg:floyd_steinberg}
    %
    \begin{algorithmic}[1]
        \Require A grayscale (0 to 1) image with dimensions $X \times Y$
        \Ensure A binary (black and white) image with the same dimensions
        \Procedure{FloydSteinberg}{Image}
        \ForAll {$0 \leq j < Y$}
        \ForAll {$0 \leq i < X$}
        \State Old $\gets$ Image[$i$, $j$]
        \State New $\gets$ \Call{Round}{Old}
        \State Error $\gets$ Old $-$ New
        \State Image[$i + 1$, $j\negphantom{j}\phantom{j + 1}$] $\gets$ Image[$i + 1$, $j\negphantom{j}\phantom{j + 1}$] $+\ \text{Err}\times 7/16$
        \State Image[$i - 1\negphantom{i-1}\phantom{i+1}$, $j + 1$] $\gets$ Image[$i - 1\negphantom{i-1}\phantom{i+1}$, $j + 1$] $+\ \text{Err}\times 3/16$
        \State Image[$i\negphantom{i}\phantom{i+1}$, $j + 1$] $\gets$ Image[$i\negphantom{i}\phantom{i+1}$, $j + 1$] $+\ \text{Err}\times 5/16$
        \State Image[$i + 1$, $j + 1$] $\gets$ Image[$i + 1$, $j + 1$] $+\ \text{Err}\times 1/16$
        \EndFor
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

% \newpage
% \subsection*{Methods -- Algorithms}
% \begin{algorithm}
%     \caption{Point Detection Algorithm for Camera Calibration}
%     \label{alg:dmd_point_detection}
%     %
%     \begin{algorithmic}[1]
%         \Require {A camera image (width $X$, height $Y$) of a point grid}
%         \Ensure {A list of the detected points}
%         %
%         \Procedure{PointDetect}{Cam}
%         \State List $\gets\{\}$
%         \ForAll {$0 \leq j < Y$}
%         \ForAll {$0 \leq i < X$}
%         \If {Cam[$i,j$] $> I_\text{threshold}$}
%         \State max $\gets 0$
%         \State $\{i_\text{max}, j_\text{max}\} \gets \{i,j\}$
%         \For {$j - 5 \leq l \leq j + 5$}
%         \For {$i - 5 \leq k \leq i + 5$}
%         \If {Cam[$k,l$] $>$ max}
%         \State max $\gets$ Cam[$k,l$]
%         \State $\{i_\text{max}, j_\text{max}\} \gets \{k,l\}$
%         \EndIf
%         \EndFor
%         \EndFor
%         \State $\{x,y\}\gets\{0,0\}$
%         \State Avg $\gets 0$
%         \For {$j_\text{max} - 5 \leq l \leq j_\text{max} + 5$}
%         \For {$i_\text{max} - 5 \leq k \leq i_\text{max} + 5$}
%         \State Avg $\gets$ Avg $+$ Cam[$k,l$]
%         \State $\{x,y\}\gets \{x,y\} + \text{Cam}[k,l] \times \{k,l\}$
%         \State Cam[$k,l$] $\gets 0$
%         \EndFor
%         \EndFor
%         \State List $\gets \{x/ \text{Avg},y/ \text{Avg}\}$
%         \EndIf
%         \EndFor
%         \EndFor
%         \EndProcedure
%     \end{algorithmic}
% \end{algorithm}
% \pagebreak
% \begin{algorithm}
%     \caption{Algorithm used to map the camera image to DMD coordinates}
%     \label{alg:dmd_mapping}
%     %
%     \begin{algorithmic}[1]
%         \Require A camera image
%         \Ensure The mapped image that now has the same dimensions as the DMD ($X\times Y$ pixels)
%         \Procedure{MapCamera}{CameraImage}
%         \ForAll {$0 \leq j < Y$}
%         \ForAll {$0 \leq i < X$}
%         \State $\{x,y\} \gets \Call{Map}{i,j}$ \Comment{The mapped coordinates, floating point}
%         \State $\{\tilde{x},\tilde{y}\} \gets \{\floor{x},\floor{y}\}$ \Comment{Integer coordinates}
%         \State WeightSum $\gets 0$
%         \State $I \gets 0$ \Comment{Weighted sum of the intensities}
%         \For {$a\in\{0,1\}$} \For {$b\in\{0,1\}$}
%         \State Weight $\gets 1/\sqrt{(x-(\tilde{x} + a))^2 + (y-(\tilde{y} + b))^2}$
%         \State WeightSum $\gets$ WeightSum $+$ Weight
%         \State $I \gets I + \text{Weight}\cdot\text{CameraImage}[\tilde{x} + a, \tilde{y} + b]$
%         \EndFor \EndFor
%         \State MappedImage[$i,j$] $\gets I / \text{WeightSum}$ 
%         \EndFor
%         \EndFor
%         \EndProcedure
%     \end{algorithmic}
% \end{algorithm}

\iffalse
\pagebreak
\subsection{Results -- Gaussian Peak as Artificial Deviation}
\vfill
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[]{DMD/Results/IntensityCut}
    \captionof{figure}[Horizontal cuts at the centre through the resulting images with fits]{Horizontal cuts at the centre through the resulting images with fits. From the image data, only every tenth value is plotted for better visibility. $A_0$ is the amplitude of the gaussian peak that has been added as a deviation.}
    \label{fig:dmd_results_gaussian_cuts}
\end{minipage}
\vfill
\fi

\pagebreak
\subsection{Results -- Sinusoidal Fringes as Artificial Deviation}
\vfill
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[]{DMD/Results/LengthScale}
    \captionof{figure}[Sinusoidal modulation pattern images with fits]{Sinusoidal modulation pattern images with fits. From the image data, only every fifth value is plotted for better visibility. $\lambda_0$ is the period of the wave that has been added as a deviation. The offset in intensity is a result of a wrong setting for the edge detection radius, which had been set to only $r=\SI{7}{px}$.}
    \label{fig:dmd_results_resolution_cuts}
\end{minipage}
\vfill
\pagebreak



\section{Evaporation}
\subsection{Theory -- Derivation of the Density of States}
\label{sec:appendix_dos}
We consider the power-law potential
\[
    U(\vec{r}) = U_x \left| \frac{x}{x_0} \right|^{\alpha_x} + U_y \left| \frac{y}{y_0} \right|^{\alpha_y} + U_z \left| \frac{z}{z_0} \right|^{\alpha_z}.
\]
The general density of states is \cite{PhysRevA.35.4354}
\begin{equation*}
    D(E) = \frac{2\pi(2m)^\frac{3}{2}}{(2\pi\hbar)^3} \underbrace{\int_{V^*(E)} \sqrt{E - U(\vec{r})}\multidiff{3}{r}}_{\equiv I(E)}
\end{equation*}
where $V^*(E)$ is the volume where $U(\vec{r}) < E$. Because the potential is symmetric along all axes, we can simplify the integration over one octant:
\begin{equation*}
    I(E) = 8\int_0^{\tilde{x}} \int_0^{\tilde{y}} \int_0^{\tilde{z}} \diff{z} \diff{y} \diff{x} \sqrt{E - U_x \left(\frac{x}{x_0}\right)^{\alpha_x} - U_y \left(\frac{y}{y_0}\right)^{\alpha_y} - U_z \left(\frac{z}{z_0}\right)^{\alpha_z}}
\end{equation*}
with
\begin{align*}
    \tilde{x} &= x_0 \left(\frac{E}{U_x}\right)^{\frac{1}{\alpha_x}}, \\ 
    \tilde{y} &= y_0 \left(\frac{E - U_x\left(\frac{x}{x_0}\right)^{\alpha_x}}{U_y}\right)^{\frac{1}{\alpha_y}}, \\ 
    \tilde{z} &= z_0 \left(\frac{E - U_x\left(\frac{x}{x_0}\right)^{\alpha_x} - U_y\left(\frac{y}{y_0}\right)^{\alpha_y} }{U_z}\right)^{\frac{1}{\alpha_z}} 
\end{align*}
We will substitute variables twice, in order not to skip too many substeps. First we substitute
\begin{equation*}
    \zeta^{\alpha_x} = U_z \left(\frac{z}{z_0}\right)^{\alpha_z}, \quad \xi^{\alpha_y} = U_y \left(\frac{y}{y_0}\right)^{\alpha_y}, \quad
    \chi^{\alpha_x} = U_x \left(\frac{x}{x_0}\right)^{\alpha_x}
\end{equation*}
to get
\begin{equation*}
    I(E) = \frac{8 x_0 y_0 z_0}{U_x^{1/\alpha_x} U_y^{1/\alpha_y} U_z^{1/\alpha_z}} \int_0^{\tilde{\chi}} \int_0^{\tilde{\xi}} \int_0^{\tilde{\zeta}} \diff{\zeta} \diff{\xi} \diff{\chi} \sqrt{E - \chi^{\alpha_x} - \xi^{\alpha_y} - \zeta^{\alpha_z}}
\end{equation*}
where we have introduced the new quantities
\begin{equation*}
    \tilde{\chi} = E^{1/\alpha_x}, \quad \tilde{\xi} = \left(E - \chi^{\alpha_x}\right)^{1/\alpha_y}, \quad \tilde{\zeta} = \left(E - \chi^{\alpha_x} - \xi^{\alpha_y}\right)^{1/\alpha_z}.
\end{equation*}
Now we substitute
\begin{equation*}
    u = \frac{\chi}{E^{1/\alpha_x}}, \quad v = \frac{\xi}{\left(E - \chi^{\alpha_x}\right)^{1/\alpha_y}}, \quad w = \frac{\zeta}{\left(E - \chi^{\alpha_x} - \xi^{\alpha_y}\right)^{1/\alpha_z}}
\end{equation*}
and we arrive at
\begin{align*}
    I(E) &= \frac{8 x_0 y_0 z_0}{U_x^{1/\alpha_x} U_y^{1/\alpha_y} U_z^{1/\alpha_z}} E^{\frac{1}{2} + \frac{1}{\alpha_x} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}} \\
    &\phantom{=} \times \underbrace{\int_0^1 \diff{u} \left(1 - u^{\alpha_x}\right)^{\frac{1}{2} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}} \int_0^1 \diff{v} \left(1 - v^{\alpha_y}\right)^{\frac{1}{2} + \frac{1}{\alpha_z}} \int_0^1 \left(1 - w^{\alpha_z}\right)^\frac{1}{2}}_{\equiv X(\alpha_x,\alpha_y,\alpha_z)}.
\end{align*}
The integral
\[
    \int_0^1 \diff{\tau} \left(1 - \tau^a\right)^b 
\]
can be related to the beta function $\text{B}(x,y)$ by substituting $t = \tau^a$
\begin{equation*}
    \int_0^1 \diff{\tau} \left(1 - \tau^a\right)^b = \frac{1}{a} \int_0^1 \diff{t}\, t^{\frac{1}{a} - 1} \left(1 - t\right)^{(b + 1) - 1} =\frac{1}{a} \text{B}\!\left(\frac{1}{a}, b + 1\right).
\end{equation*}
Using this simplifies $X(\alpha_x,\alpha_y,\alpha_z)$ to 
\begin{equation*}
    X(\alpha_x,\alpha_y,\alpha_z) = \frac{1}{\alpha_x \alpha_y \alpha_z} \text{B}\!\left(\frac{1}{\alpha_x}, \frac{3}{2} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z} \right) \cdot \text{B}\!\left(\frac{1}{\alpha_y}, \frac{3}{2} + \frac{1}{\alpha_z} \right) \cdot \text{B}\!\left(\frac{1}{\alpha_z}, \frac{3}{2}\right).
\end{equation*}
We can simplify this even further by using the relation of the Beta function to the Gamma function:
\begin{equation*}
    \text{B}(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x + y)}
\end{equation*}
\begin{align*}
    \Rightarrow \quad X(\alpha_x,\alpha_y,\alpha_z) &= \frac{1}{\alpha_x \alpha_y \alpha_z} \frac{\Gamma\!\left(\frac{1}{\alpha_x}\right) \Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}\right)}{\Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_x} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}\right)} \frac{\Gamma\!\left(\frac{1}{\alpha_y}\right) \Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_z}\right)}{\Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}\right)} \frac{\Gamma\!\left(\frac{1}{\alpha_z}\right) \Gamma\!\left(\frac{3}{2}\right)}{\Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_z}\right)} \\
    &= \frac{1}{\alpha_x \alpha_y \alpha_z} \frac{\Gamma\!\left(\frac{1}{\alpha_x}\right) \Gamma\!\left(\frac{1}{\alpha_y}\right) \Gamma\!\left(\frac{1}{\alpha_z}\right) \Gamma\!\left(\frac{3}{2}\right)}{\Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_x} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}\right)} \qquad \Big| \, x\Gamma(x) = \Gamma(x + 1) \\
    &= \frac{\sqrt{\pi}}{2}\cdot\frac{\Gamma\!\left(1 + \frac{1}{\alpha_x}\right) \Gamma\!\left(1 + \frac{1}{\alpha_y}\right) \Gamma\!\left(1 + \frac{1}{\alpha_z}\right)}{\Gamma\!\left(\frac{3}{2} + \frac{1}{\alpha_x} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}\right)} \\
    &\equiv \frac{\sqrt{\pi}}{2} \times \frac{F(\alpha_x,\alpha_y,\alpha_z)}{\Gamma(\xi)}
\end{align*}
where
\begin{align*}
    F(\alpha_x,\alpha_y,\alpha_z) &= \Gamma\!\left(1 + \frac{1}{\alpha_x}\right) \Gamma\!\left(1 + \frac{1}{\alpha_y}\right) \Gamma\!\left(1 + \frac{1}{\alpha_z}\right) 
    \intertext{and} 
    \xi &= \frac{3}{2} + \frac{1}{\alpha_x} + \frac{1}{\alpha_y} + \frac{1}{\alpha_z}.
\end{align*}
So finally, the complete density of states is given by
\begin{equation*}
    D(E) = \left(\frac{2m}{\pi\hbar^2}\right)^\frac{3}{2} \frac{x_0 y_0 z_0}{U_x^{1/\alpha_x} U_y^{1/\alpha_y} U_z^{1/\alpha_z}} \frac{F(\alpha_x,\alpha_y,\alpha_z)}{\Gamma(\xi)} \times E^{\xi - 1}
\end{equation*}

\pagebreak
\subsection{Implementation -- Custom Adaptive Runge Kutta}
\begin{algorithm}
    \caption{Particle Movement Procedure with Adaptive Runge-Kutta Method}
    \label{alg:dsmc_movement_impl}
    %
    \begin{algorithmic}[1]
    \Require \Dt, the timestep to propagate each particle forward by
    \Procedure {MoveStep}{\Dt}
    \newcommand*{\TOL}{\ensuremath{\Delta_\text{tolerance}}\xspace}
    \State $\TOL = \num{e-7}$ \Comment{tolerance parameter}
    \ForAll {particles $A \in$ cloud}
    \State $t \gets 0$ \Comment{time passed}
    \State $\Dt_\text{local} \gets \min (\classprop{A}{\delta t}, \Dt)$ \Comment{local timestep}
    \While {$t < \Dt$}
    \State $\{K[0], L[0]\} \gets \Dt_\text{local}\cdot \{ \Call{Force}{\classprop{A}{\vec{r}}}/m , \classprop{A}{\vec{v}}  \}$
    \State $\{K[1], L[1]\} \gets \Dt_\text{local}\cdot \{ \Call{Force}{\classprop{A}{\vec{r}} + 0.5\cdot L[0]}/m , \classprop{A}{\vec{v}} + 0.5\cdot K[0]  \}$
    \State $\{K[2], L[2]\} \gets \Dt_\text{local}\cdot \{ \Call{Force}{\classprop{A}{\vec{r}} + 0.5\cdot L[1]}/m , \classprop{A}{\vec{v}} + 0.5\cdot K[1]  \}$
    \State $\{K[3], L[3]\} \gets \Dt_\text{local}\cdot \{ \Call{Force}{\classprop{A}{\vec{r}} + L[2]}/m , \classprop{A}{\vec{v}} + K[2] \}$
    \Statex
    \State $\vec{r}' \gets \classprop{A}{\vec{r}} + 1/6\cdot(L[0] + 2\cdot L[1] + 2\cdot L[2] + L[3])$
    \State $\vec{v}' \gets \classprop{A}{\vec{v}} + 1/6\cdot(K[0] + 2\cdot K[1] + 2\cdot K[2] + K[3])$
    \Statex
    \State $E_0 \gets m/2 \cdot (\classprop{A}{\vec{v}})^2 + \Call{Potential}{\classprop{A}{\vec{r}}}$ \Comment{total energy before}
    \State $E \gets m/2 \cdot (\vec{v}')^2 + \Call{Potential}{\classprop{A}{\vec{r}'}}$ \Comment{total energy after}
    \State $\Delta E \gets$ \Ternary{$E_0 \neq 0$}{$|E-E_0|/E_0$}{$\num{0.999}\cdot \TOL$}
    \Statex
    \If {$\Delta E < \TOL$}
    \State $t \gets t + \Dt_\text{local}$ \Comment{advance the time tracker}
    \State $\{\classprop{A}{\vec{r}}, \classprop{A}{\vec{v}}\} \gets \{\vec{r}', \vec{v}'\}$ \Comment{apply the changes in position and velocity}
    \EndIf
    \Statex
    \State $\Dt_\text{local} \gets \Dt_\text{local}\cdot$ \Ternary{$\Delta E \neq 0$}{$0.9 \cdot (\TOL / \Delta E)^{\num{0.25}}$}{$10$}
    \Statex
    \If {$t + \Dt_\text{local} > \Dt$}
    \State $\classprop{A}{\delta t} \gets \Dt_\text{local}$ \Comment{update local timestep of this particle}
    \State $\Dt_\text{local} \gets \Dt - t$ \Comment{do not go beyond \Dt}
    \EndIf
    \EndWhile
    \EndFor
    \EndProcedure
    \end{algorithmic}
\end{algorithm}